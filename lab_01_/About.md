# Пояснення
> У цьому файлі я пояснюю, що було зроблено у лабораторних.

## Число фібоначі - fib_num
```rust
fn main(){
    let n:u32 = 20;
    println!("fib({}) = {}", n, fib(n));
  }
  
  fn fib(n:u32) -> u32{
    if n <= 1{
      n
    }
    else{
      fib(n-1) + fib(n-2)
    }
  }
```

> Це програма, котра обраховує число фібоначі, у ній є функція мейн, котра записує число `n` котре обрахувати, точніше його ітерацію, а саме 20 у цьому випадку, далі ж вже є функція, котра і обраховує це число, зроблено виключення, якщо n<=1 то буде n, що в цілому у алгорітмі так і відбувається. Якщо ж не менше або = 1, то буде виконуватись рекурсивна ф-ція, у котрій все відбувається так:fib(19)-fib(18), далі через те що fib не дорівнює одному або менше, то воно розкладається далі по такому ж сценарію.


## Таблиця множення - pif_tabl
```rust
fn main() {
    let size: i32 = 10;  

    print!("    ");  
    for i in 1..=size {
        print!("{:4}", i); 
    }
    println!(); 

    for i in 1..=size {
        print!("{:3} |", i); 
        for j in 1..=size {
            print!("{:4}", i * j);  
        }
        println!(); 
    }
}
```

> Це програма котра виводить таблицю множення, тут задається розмір у змінній `size` далі робиться прінт пустого місця, а саме 4 пробілів та робиться цикл котрий виводить першу строчку, з відстанню між обʼєктами також у 4 пробіли, що вказано у плейсхолдері, та після циклу робиться нова строка. Далі наступним чином робиться наступний цикл, котрий і виводить всю таблицю множення, у першому циклі виводиться у стовпець число з | та після у другому циклі вже виводить добуток чисел i та j, та після другого циклу виводиться нова строка. 